// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title MerkleTree
 * @notice Fixed-height Incremental Merkle Tree library using Keccak256
 * @dev This implementation matches the Rust implementation in core/src/merkle.rs
 *
 * Key features:
 * - Fixed height of 32 levels (supports 2^32 leaves)
 * - Uses Keccak256 for EVM gas efficiency
 * - Incremental updates: O(32) hashes per insert
 * - Precomputed zero hashes for empty subtrees
 *
 * Security:
 * - Deterministic root computation ensures consensus with ZK circuit
 * - Proof verification is independent of tree state
 */
library MerkleTree {
    /// @notice Tree height (32 levels = 2^32 max leaves)
    uint256 public constant TREE_HEIGHT = 32;

    /// @notice Precomputed zero hashes for each level
    /// @dev ZEROS[0] = bytes32(0), ZEROS[i] = keccak256(ZEROS[i-1], ZEROS[i-1])
    /// These are computed once and stored as constants for gas efficiency
    function zeros(uint256 level) internal pure returns (bytes32) {
        // Precomputed zero hashes
        // Generated by: hash(zeros[i-1], zeros[i-1]) for each level
        if (level == 0) return bytes32(0);
        if (level == 1) return 0xad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5;
        if (level == 2) return 0xb4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d30;
        if (level == 3) return 0x21ddb9a356815c3fac1026b6dec5df3124afbadb485c9ba5a3e3398a04b7ba85;
        if (level == 4) return 0xe58769b32a1beaf1ea27375a44095a0d1fb664ce2dd358e7fcbfb78c26a19344;
        if (level == 5) return 0x0eb01ebfc9ed27500cd4dfc979272d1f0913cc9f66540d7e8005811109e1cf2d;
        if (level == 6) return 0x887c22bd8750d34016ac3c66b5ff102dacdd73f6b014e710b51e8022af9a1968;
        if (level == 7) return 0xffd70157e48063fc33c97a050f7f640233bf646cc98d9524c6b92bcf3ab56f83;
        if (level == 8) return 0x9867cc5f7f196b93bae1e27e6320742445d290f2263827498b54fec539f756af;
        if (level == 9) return 0xcefad4e508c098b9a7e1d8feb19955fb02ba9675585078710969d3440f5054e0;
        if (level == 10) return 0xf9dc3e7fe016e050eff260334f18a5d4fe391d82092319f5964f2e2eb7c1c3a5;
        if (level == 11) return 0xf8b13a49e282f609c317a833fb8d976d11517c571d1221a265d25af778ecf892;
        if (level == 12) return 0x3490c6ceeb450aecdc82e28293031d10c7d73bf85e57bf041a97360aa2c5d99c;
        if (level == 13) return 0xc1df82d9c4b87413eae2ef048f94b4d3554cea73d92b0f7af96e0271c691e2bb;
        if (level == 14) return 0x5c67add7c6caf302256adedf7ab114da0acfe870d449a3a489f781d659e8becc;
        if (level == 15) return 0xda7bce9f4e8618b6bd2f4132ce798cdc7a60e7e1460a7299e3c6342a579626d2;
        if (level == 16) return 0x2733e50f526ec2fa19a22b31e8ed50f23cd1fdf94c9154ed3a7609a2f1ff981f;
        if (level == 17) return 0xe1d3b5c807b281e4683cc6d6315cf95b9ade8641defcb32372f1c126e398ef7a;
        if (level == 18) return 0x5a2dce0a8a7f68bb74560f8f71837c2c2ebbcbf7fffb42ae1896f13f7c7479a0;
        if (level == 19) return 0xb46a28b6f55540f89444f63de0378e3d121be09e06cc9ded1c20e65876d36aa0;
        if (level == 20) return 0xc65e9645644786b620e2dd2ad648ddfcbf4a7e5b1a3a4ecfe7f64667a3f0b7e2;
        if (level == 21) return 0xf4418588ed35a2458cffeb39b93d26f18d2ab13bdce6aee58e7b99359ec2dfd9;
        if (level == 22) return 0x5a9c16dc00d6ef18b7933a6f8dc65ccb55667138776f7dea101070dc8796e377;
        if (level == 23) return 0x4df84f40ae0c8229d0d6069e5c8f39a7c299677a09d367fc7b05e3bc380ee652;
        if (level == 24) return 0xcdc72595f74c7b1043d0e1ffbab734648c838dfb0527d971b602bc216c9619ef;
        if (level == 25) return 0x0abf5ac974a1ed57f4050aa510dd9c74f508277b39d7973bb2dfccc5eeb0618d;
        if (level == 26) return 0xb8cd74046ff337f0a7bf2c8e03e10f642c1886798d71806ab1e888d9e5ee87d0;
        if (level == 27) return 0x838c5655cb21c6cb83313b5a631175dff4963772cce9108188b34ac87c81c41e;
        if (level == 28) return 0x662ee4dd2dd7b2bc707961b1e646c4047669dcb6584f0d8d770daf5d7e7deb2e;
        if (level == 29) return 0x388ab20e2573d171a88108e79d820e98f26c0b84aa8b2f4aa4968dbb818ea322;
        if (level == 30) return 0x93237c50ba75ee485f4c22adf2f741400bdf8d6a9cc7df7ecae576221665d735;
        if (level == 31) return 0x8448818bb4ae4562849e949e17ac16e0be16688e156b5cf15e098c627c0056a9;
        revert("Invalid level");
    }

    /// @notice Hash two nodes together
    /// @dev This matches keccak256(abi.encodePacked(left, right)) and Rust's hash_pair
    function hashPair(bytes32 left, bytes32 right) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(left, right));
    }

    /// @notice Verify a Merkle proof
    /// @param leaf The leaf to verify
    /// @param leafIndex The index of the leaf in the tree
    /// @param siblings The sibling hashes from leaf to root
    /// @param expectedRoot The expected root hash
    /// @return True if the proof is valid
    function verifyProof(
        bytes32 leaf,
        uint256 leafIndex,
        bytes32[] memory siblings,
        bytes32 expectedRoot
    ) internal pure returns (bool) {
        bytes32 current = leaf;
        uint256 index = leafIndex;

        for (uint256 level = 0; level < siblings.length && level < TREE_HEIGHT; level++) {
            if (index % 2 == 0) {
                // We're on the left
                current = hashPair(current, siblings[level]);
            } else {
                // We're on the right
                current = hashPair(siblings[level], current);
            }
            index = index / 2;
        }

        return current == expectedRoot;
    }

    /// @notice Incremental Merkle Tree state
    struct Tree {
        /// @notice Current root
        bytes32 root;
        /// @notice Number of leaves inserted
        uint256 nextIndex;
        /// @notice Filled subtrees at each level (for incremental updates)
        bytes32[TREE_HEIGHT] filledSubtrees;
    }

    /// @notice Initialize a new empty tree
    function init(Tree storage tree) internal {
        tree.root = zeros(TREE_HEIGHT - 1);
        tree.nextIndex = 0;
        for (uint256 i = 0; i < TREE_HEIGHT; i++) {
            tree.filledSubtrees[i] = zeros(i);
        }
    }

    /// @notice Insert a new leaf into the tree
    /// @param tree The tree state
    /// @param leaf The leaf to insert
    /// @return The new root and the index where the leaf was inserted
    function insert(Tree storage tree, bytes32 leaf) internal returns (bytes32, uint256) {
        uint256 index = tree.nextIndex;
        require(index < 2**TREE_HEIGHT, "Tree is full");

        bytes32 currentHash = leaf;
        uint256 currentIndex = index;

        for (uint256 level = 0; level < TREE_HEIGHT; level++) {
            if (currentIndex % 2 == 0) {
                // We're on the left, update filled subtree
                tree.filledSubtrees[level] = currentHash;
                // Hash with zero on right (empty subtree)
                currentHash = hashPair(currentHash, zeros(level));
            } else {
                // We're on the right, hash with filled subtree on left
                currentHash = hashPair(tree.filledSubtrees[level], currentHash);
            }
            currentIndex = currentIndex / 2;
        }

        tree.nextIndex = index + 1;
        tree.root = currentHash;

        return (currentHash, index);
    }
}
